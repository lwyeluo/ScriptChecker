/*
 * The core of ScriptCheck running in the renderer process
 *  Author: Luo Wu
 */
#include "base/scriptchecker/global.h"
#include "base/scriptchecker/task_type.h"

namespace base {

namespace scriptchecker {

ScriptChecker::ScriptChecker() {
  m_current_task_ = nullptr;
  m_capability_definition = new CapabilityDefinition();
  m_async_exec_queue_ = new AsyncExecQueue();
}

ScriptChecker::~ScriptChecker() {
  delete m_capability_definition;
}

void ScriptChecker::UpdateCurrentTask(PendingTask* task) {
  DCHECK(task);
  m_current_task_ = task;

#ifdef SCRIPT_CHECKER_INSPECT_TASK_SCEDULER
  LOG(INFO) << g_name << "ScriptChecker::UpdateCurrentTask. [seq, cap] = "
            << m_current_task_->sequence_num << ", " << m_current_task_->GetCapbilityAsJSString()
            << ", " << m_current_task_->posted_from.function_name();
#endif
}

void ScriptChecker::RunAsyncExecTasks(base::debug::TaskAnnotator* task_annotator) {
  m_async_exec_queue_->RunAll(task_annotator);
}

void ScriptChecker::RecordNewTask(PendingTask *task) {
  DCHECK(task);
  if(IsCurrentTaskWithRestricted()) {
    // the task is from other thread, so the new task
    //   cannot use the current task as its parent
    if(base::PlatformThread::CurrentId() != 1)
      return;

#ifdef SCRIPT_CHECKER_INSPECT_TASK_SCEDULER
    // now the task is generated by the main thread
    LOG(INFO) << g_name << "ScriptChecker::RecordNewTask with restricted capabilty. [seq, task_type, cap] = "
              << task->sequence_num << ", " << task->task_type_in_scriptchecker_
              << ", " << task->GetCapbilityAsJSString()
              << ", " << m_current_task_->IsTaskRestricted() << ", "
              << m_current_task_->GetCapbilityAsJSString() << ", "
              << m_current_task_->sequence_num;
#endif
    // try to update the capability with its parent task
    switch(task->task_type_in_scriptchecker_) {
      case TaskType::NORMAL_TASK:
        // the parent is the current task
        task->SetCapability(GetCurrentTaskCapability());
        break;
      case TaskType::IPC_TASK:
        // its capabilty is set accoding to the IPC message, see ScriptChecker::RecordIPCTask
      case TaskType::SCHEDULER_TASK:
        // its capability should be full privilege
        break;
      case TaskType::NORMAL_TIMER_TASK:
      case TaskType::SETTIMEOUTWR_DELAY_ZERO_TIMER_TASK:
        // we have set the capability according to the JS API's parameter, here we need to
        //  ensure that the assigned capability does not breach its parent
        task->NarrowDownCapability(m_current_task_->capability_);
        break;
      default:
        // here is unreachable
        NOTREACHED();
    }
  }
//  if(m_current_task_)
//    LOG(INFO) << "\t\tm_current_task's [seq, cap] = " << m_current_task_->sequence_num
//              << ", " << m_current_task_->GetCapbilityAsJSString();
}

void ScriptChecker::RecordNewAsyncExecTask(PendingTask &&task) {
  DCHECK(task.task_type_in_scriptchecker_ == TaskType::SETTIMEOUTWR_DELAY_ZERO_TIMER_TASK);

  LOG(INFO) << g_name << "ScriptChecker::RecordNewAsyncExecTask. [newtaskid] = "
            << task.sequence_num;

  // check capability
  task.NarrowDownCapability(m_current_task_->capability_);
  // record into async exec queue
  m_async_exec_queue_->Push(std::move(task));
}

void ScriptChecker::RecordIPCTask(std::string capability_attached_in_ipc_message) {
  // here should be attached into the current task which forms as IPC_TASK
  DCHECK(m_current_task_);
#ifdef SCRIPT_CHECKER_INSPECT_TASK_SCEDULER
  LOG(INFO) << g_name << "ScriptChecker::RecordIPCTask. [cap_in_ipc] = "
            << capability_attached_in_ipc_message;
#endif
  m_current_task_->SetCapabilityFromIPCMessage(capability_attached_in_ipc_message);
}

bool ScriptChecker::IsCurrentTaskWithRestricted() {
  return m_current_task_ ? m_current_task_->IsTaskRestricted() : false;
}

Capability* ScriptChecker::GetCurrentTaskCapability() {
  return m_current_task_->capability_;
}

int ScriptChecker::GetCurrentTaskID() {
  return m_current_task_->sequence_num;
}

void ScriptChecker::UpdateCurrentTaskCapability(std::string task_capability) {
  m_current_task_->SetCapabilityFromJSString(task_capability);
}

void ScriptChecker::UpdateCurrentTaskCapability(Capability* capability) {
  if(capability && capability->IsRestricted())
    m_current_task_->NarrowDownCapability(capability);
}

std::string ScriptChecker::GetCurrentTaskCapabilityAsJSString() {
  return m_current_task_->GetCapbilityAsJSString();
}

bool ScriptChecker::MatchWithCapabilityJSRules(std::string in_capability_js_str,
                                               uint64_t& out_capability_bit_map,
                                               std::map<std::string, bool>& out_capability_js_wl) {
  return m_capability_definition->rule.Match(in_capability_js_str,
                                             out_capability_bit_map,
                                             out_capability_js_wl);
}

std::string ScriptChecker::ToJSStringFromCapabilityBitmap(uint64_t capability_bitmap) {
  return m_capability_definition->rule.ToJSStringFromBitMap(capability_bitmap);
}

CapabilityDefinition* ScriptChecker::GetCapabilityJSStringRules() {
  return m_capability_definition;
}

// Security Monitor
bool ScriptChecker::DisallowedToAccessNetwork() {
  if(!m_current_task_->IsTaskRestricted())
    return false;
  return CapabilityDefinition::DisallowedToAccessNetwork(
              m_current_task_->capability_->GetBitmap());
}
bool ScriptChecker::DisallowedToAccessDOM(bool is_ele_has_task_cap_attr) {
  if(!m_current_task_->IsTaskRestricted())
    return false;
  return CapabilityDefinition::DisallowedToAccessDOM(
              m_current_task_->capability_->GetBitmap(),
              is_ele_has_task_cap_attr);
}
bool ScriptChecker::DisallowedToAccessJSObject(std::string object_name) {
  if(!m_current_task_->IsTaskRestricted())
    return false;
  return !m_current_task_->capability_->ContainsInJSWL(object_name);
}

}

}
