/*
 * The core of ScriptCheck running in the renderer process
 *  Author: Luo Wu
 */
#include "base/scriptchecker/global.h"
#include "base/scriptchecker/task_type.h"
#include "base/debug/stack_trace.h"

namespace base {

namespace scriptchecker {

ScriptChecker::ScriptChecker() {
  m_current_task_ = nullptr;
  m_capability_definition = new CapabilityDefinition();
  m_async_exec_queue_ = new AsyncExecQueue();
  m_has_restricted_frame_parser_task_ = false;
}

ScriptChecker::~ScriptChecker() {
  delete m_capability_definition;
}

void ScriptChecker::UpdateCurrentTask(PendingTask* task) {
  DCHECK(task);
  m_current_task_ = task;

  m_has_restricted_frame_parser_task_ = false;

#ifdef SCRIPT_CHECKER_INSPECT_TASK_SCEDULER
  LOG(INFO) << g_name << "ScriptChecker::UpdateCurrentTask. [seq, cap] = "
            << m_current_task_->sequence_num << ", " << m_current_task_->GetCapbilityAsJSString()
            << ", " << m_current_task_->posted_from.function_name() << ", " << m_current_task_;
#endif
}

void ScriptChecker::RunAsyncExecTasks() {
  m_async_exec_queue_->RunAll();
}

size_t ScriptChecker::GetAsyncExecTaskSize() {
  return m_async_exec_queue_->Size();
}

void ScriptChecker::StartTimeMeasureForAsyncTask() {
  struct TIME_MEASURE *time_measure = new struct TIME_MEASURE();
  memset(time_measure, 0, sizeof(struct TIME_MEASURE));
  gettimeofday(&time_measure->time_begin, 0);
  time_measure->cpu_begin = _rdtsc();
  time_measure->task_id = m_async_exec_queue_->GetLastTaskId();
  time_measure->is_valid = true;

  m_time_measure_map_[time_measure->task_id] = time_measure;
}

void ScriptChecker::FinishTimeMeasureForAsyncTask() {
  auto iter = m_time_measure_map_.find(GetCurrentTaskID());
  if(iter == m_time_measure_map_.end())
    return;

  struct TIME_MEASURE* time_measure = m_time_measure_map_[GetCurrentTaskID()];
  if(time_measure->is_valid) {
    gettimeofday(&time_measure->time_end, 0);
    time_measure->cpu_end = _rdtsc();

    subTimeVal(time_measure->time_diff,
               time_measure->time_begin,
               time_measure->time_end);

    LOG(INFO) << g_name << "ScheduleAsnycTaskForSetTimeoutWR"
              << "[is_risky_task, cpu_cycle, time] = " << IsCurrentTaskWithRestricted() << ", "
              << (time_measure->cpu_end - time_measure->cpu_begin) << ", "
              << (time_measure->time_diff.tv_sec * 1000000 + time_measure->time_diff.tv_usec) << "Î¼s! ";

    delete time_measure;
    m_time_measure_map_.erase(iter);
  }
}

void ScriptChecker::RecordNewTask(PendingTask *task) {
  // the task is from other thread, so the new task
  //   cannot use the current task as its parent
  if(base::PlatformThread::CurrentId() != 1)
    return;

  DCHECK(task);
  if(IsCurrentTaskWithRestricted()) {
#ifdef SCRIPT_CHECKER_INSPECT_TASK_SCEDULER
    // now the task is generated by the main thread
    LOG(INFO) << g_name << "ScriptChecker::RecordNewTask with restricted capabilty. [seq, task_type, cap] = "
              << task->sequence_num << ", " << task->task_type_in_scriptchecker_
              << ", " << task->GetCapbilityAsJSString()
              << ", " << m_current_task_->IsTaskRestricted() << ", "
              << m_current_task_->GetCapbilityAsJSString() << ", "
              << m_current_task_->sequence_num << ", "
              << task->posted_from.ToString();
#endif
    // try to update the capability with its parent task
    switch(task->task_type_in_scriptchecker_) {
      case TaskType::NORMAL_TASK:
        // the parent is the current task
        task->SetCapability(GetCurrentTaskCapability());
        break;
      case TaskType::IPC_TASK:
        // its capabilty is set accoding to the IPC message, see ScriptChecker::RecordIPCTask
      case TaskType::NORMAL_TIMER_TASK:
      case TaskType::SETTIMEOUTWR_DELAY_NONZERO_TIMER_TASK:
      case TaskType::SETTIMEOUTWR_DELAY_ZERO_TIMER_TASK:
        // we have set the capability according to the JS API's parameter, here we need to
        //  ensure that the assigned capability does not breach its parent
        task->NarrowDownCapability(m_current_task_->capability_);
        break;
      case TaskType::SCHEDULER_TASK:
      case TaskType::NORMAL_FRAME_PARSER_TASK:
        // its capability should be full privilege
        break;
      default:
        // here is unreachable
        NOTREACHED();
    }
  }
//  if(m_current_task_)
//    LOG(INFO) << "\t\tm_current_task's [seq, cap] = " << m_current_task_->sequence_num
//              << ", " << m_current_task_->GetCapbilityAsJSString();
}

#ifndef SCRIPT_CHECKER_SEPERATE_FRAME_PARSER
void ScriptChecker::UpdateCurrentTaskCapability(std::string task_capability) {
  m_current_task_->SetCapabilityFromJSString(task_capability);
}

void ScriptChecker::UpdateCurrentTaskCapability(Capability* capability) {
  if(capability && capability->IsRestricted())
    m_current_task_->NarrowDownCapability(capability);
}
#endif

void ScriptChecker::RecordNewAsyncExecTask(PendingTask &&task) {
  DCHECK(task.task_type_in_scriptchecker_ == TaskType::SETTIMEOUTWR_DELAY_ZERO_TIMER_TASK ||
         task.task_type_in_scriptchecker_ == TaskType::RESTRICTED_LISTENER_TASK);
  DCHECK(task.capability_);

#ifdef SCRIPT_CHECKER_PRINT_SECURITY_MONITOR_LOG
  LOG(INFO) << g_name << "ScriptChecker::RecordNewAsyncExecTask. [newtaskid] = "
            << task.sequence_num << ", " << m_current_task_->task_type_in_scriptchecker_
            << ", " << GetCurrentTaskCapabilityAsJSString();
#endif
  // check capability
  if(m_current_task_->IsTaskRestricted())
    task.NarrowDownCapability(m_current_task_->capability_);
  // record into async exec queue
  m_async_exec_queue_->Push(std::move(task));
}

void ScriptChecker::RecordRestrictedFrameParserTask(PendingTask&& task) {
  DCHECK(task.task_type_in_scriptchecker_ == TaskType::RESTRICTED_FRAME_PARSER_TASK);
  DCHECK(task.capability_);
#ifdef SCRIPT_CHECKER_PRINT_SECURITY_MONITOR_LOG
  LOG(INFO) << g_name << "ScriptChecker::RecordRestrictedFrameParserTask. [newtaskid] = "
            << task.sequence_num << ", " << task.capability_->ToString();
#endif
  // record into async exec queue
  m_async_exec_queue_->Push(std::move(task));
  // update the flag
  m_has_restricted_frame_parser_task_ = true;
}

void ScriptChecker::RecordRiskyScriptDownloadededFromNetwork(
        std::string capability_in_js) {
#ifdef SCRIPT_CHECKER_PRINT_SECURITY_MONITOR_LOG
  LOG(INFO) << ">>> ScriptChecker::RecordRiskyScriptDownloadededFromNetwork";
#endif
  m_current_task_->SetCapabilityFromJSString(capability_in_js);
}

void ScriptChecker::RecordNormalRestrictedFrameParserTask(PendingTask &&task) {
  DCHECK(task.task_type_in_scriptchecker_ == TaskType::NORMAL_FRAME_PARSER_TASK);
  DCHECK(!task.capability_);
#ifdef SCRIPT_CHECKER_PRINT_SECURITY_MONITOR_LOG
  LOG(INFO) << g_name << "ScriptChecker::RecordNormalRestrictedFrameParserTask. [newtaskid] = "
            << task.sequence_num;
#endif
  // record into async exec queue
  m_async_exec_queue_->Push(std::move(task));
  // update the flag
  m_has_restricted_frame_parser_task_ = false;
}

void ScriptChecker::FinishRestrictedFrameParserTask() {
  m_has_restricted_frame_parser_task_ = true;
}

void ScriptChecker::RecordIPCTask(std::string capability_attached_in_ipc_message) {
  // here should be attached into the current task which forms as IPC_TASK
  DCHECK(m_current_task_);
  m_current_task_->SetCapabilityFromIPCMessage(capability_attached_in_ipc_message);
}

bool ScriptChecker::IsCurrentTaskWithRestricted() {
  return m_current_task_ ? m_current_task_->IsTaskRestricted() : false;
}

Capability* ScriptChecker::GetCurrentTaskCapability() {
  return m_current_task_->capability_;
}

int ScriptChecker::GetCurrentTaskID() {
  return m_current_task_ ? m_current_task_->sequence_num : -10000;
}

bool ScriptChecker::IsCurrentTaskHasRestrictedFrameParserTask() {
  return m_has_restricted_frame_parser_task_;
}

bool ScriptChecker::IsCurrentTaskNormalFrameParser() {
  if(m_current_task_)
    return m_current_task_->task_type_in_scriptchecker_
            == TaskType::NORMAL_FRAME_PARSER_TASK;
  return false;
}

std::string ScriptChecker::GetCurrentTaskCapabilityAsJSString() {
  return m_current_task_->GetCapbilityAsJSString();
}

bool ScriptChecker::MatchWithCapabilityJSRules(std::string in_capability_js_str,
                                               uint64_t& out_capability_bit_map,
                                               std::map<std::string, bool>& out_capability_js_wl) {
  return m_capability_definition->rule.Match(in_capability_js_str,
                                             out_capability_bit_map,
                                             out_capability_js_wl);
}

std::string ScriptChecker::ToJSStringFromCapabilityBitmap(uint64_t capability_bitmap) {
  return m_capability_definition->rule.ToJSStringFromBitMap(capability_bitmap);
}

CapabilityDefinition* ScriptChecker::GetCapabilityJSStringRules() {
  return m_capability_definition;
}

// Security Monitor
bool ScriptChecker::DisallowedToAccessNetwork() {
  if(!m_current_task_->IsTaskRestricted())
    return false;
  return CapabilityDefinition::DisallowedToAccessNetwork(
              m_current_task_->capability_->GetBitmap());
}
bool ScriptChecker::DisallowedToAccessDOM(bool is_ele_has_task_cap_attr) {
  if(!m_current_task_->IsTaskRestricted())
    return false;
  return CapabilityDefinition::DisallowedToAccessDOM(
              m_current_task_->capability_->GetBitmap(),
              is_ele_has_task_cap_attr);
}
bool ScriptChecker::DisallowedToAccessJSObject(std::string object_name) {
  if(object_name == "") // we dont know the object, update this code in the futher
    return false;
  if(!m_current_task_->IsTaskRestricted())
    return false;
  return !m_current_task_->capability_->ContainsInJSWL(object_name);
}
bool ScriptChecker::DisallowedToAccessCookie() {
  if(!m_current_task_->IsTaskRestricted())
    return false;
  return CapabilityDefinition::DisallowedToAccessCookie(
              m_current_task_->capability_->GetBitmap());
}

}

}
